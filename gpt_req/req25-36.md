Stage 25 â€” è¦åŠƒå¸³è™Ÿç³»çµ±ï¼ˆAuthentication Flow è¨­è¨ˆï¼‰

ä½ çš„ P2P Chat æœ¬è³ªæ˜¯ P2Pï¼Œä½†ä½¿ç”¨è€…å¸³è™Ÿéœ€è¦é›†ä¸­ç®¡ç†ã€‚
å› æ­¤å¸³è™Ÿ ä¸èµ° P2Pï¼Œè€Œæ˜¯ï¼š

Browser â†’ HTTP â†’ Auth Server â†’ DB
P2P åªè² è²¬èŠå¤©ï¼Œä¸è² è²¬å¸³è™Ÿ


æµç¨‹å¦‚ä¸‹ï¼š

ä½¿ç”¨è€…é–‹å•Ÿ UI â†’ é¡¯ç¤º Login / Register

ä½¿ç”¨è€…è¼¸å…¥å¸³å¯† â†’ å‚³é€åˆ° Auth APIï¼ˆGo REST serverï¼‰

é©—è­‰å¾Œè¿”å›ï¼š

JWT Tokenï¼ˆå¾Œç«¯ç”¨ä¾†è­˜åˆ¥ userï¼‰

username

UI å­˜ tokenï¼Œä¹‹å¾Œé€²å…¥ chat UI

é€²å…¥ P2P chat æ™‚ï¼Œä½¿ç”¨ token çš„ username ç•¶ä½œç™¼è©±è€…

Stage 26 â€” DB é¸æ“‡èˆ‡ Schema è¨­è¨ˆ
å»ºè­°ä½¿ç”¨ SQLiteï¼ˆLocal æ¸¬è©¦æœ€ç°¡å–®ï¼‰

Schemaï¼š

CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Stage 27 â€” æ–°å¢ Auth Serverï¼ˆGo REST APIï¼‰

å»ºç«‹ auth/main.go

package main

import (
    "database/sql"
    "log"
    "net/http"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/httplog"
    "github.com/go-chi/cors"
    _ "github.com/mattn/go-sqlite3"
)

func main() {
    logger := httplog.NewLogger("auth", httplog.Options{JSON: true})

    db, err := sql.Open("sqlite3", "./users.db")
    if err != nil { panic(err) }

    r := chi.NewRouter()
    r.Use(cors.Handler(cors.Options{
        AllowedOrigins: []string{"*"},
        AllowedMethods: []string{"GET", POST, OPTIONS},
    }))

    r.Post("/register", Register(db))
    r.Post("/login", Login(db))

    log.Println("Auth server running at :8089")
    http.ListenAndServe(":8089", httplog.RequestLogger(logger)(r))
}

Stage 28 â€” Register API
func Register(db *sql.DB) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req struct {
            Username string `json:"username"`
            Password string `json:"password"`
        }
        json.NewDecoder(r.Body).Decode(&req)

        hash, _ := bcrypt.GenerateFromPassword([]byte(req.Password), 12)

        _, err := db.Exec(`
            INSERT INTO users (username, password_hash) VALUES (?, ?)
        `, req.Username, hash)

        if err != nil {
            http.Error(w, "username exists", 400)
            return
        }

        json.NewEncoder(w).Encode(map[string]string{
            "status": "ok",
        })
    }
}

Stage 29 â€” Login APIï¼ˆå›å‚³ JWTï¼‰
func Login(db *sql.DB) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req struct {
            Username string `json:"username"`
            Password string `json:"password"`
        }
        json.NewDecoder(r.Body).Decode(&req)

        var storedHash string
        err := db.QueryRow(`
            SELECT password_hash FROM users WHERE username = ?
        `, req.Username).Scan(&storedHash)
        if err != nil {
            http.Error(w, "invalid username", 400)
            return
        }

        if bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(req.Password)) != nil {
            http.Error(w, "wrong password", 400)
            return
        }

        token := createJWT(req.Username)

        json.NewEncoder(w).Encode(map[string]string{
            "token": token,
            "username": req.Username,
        })
    }
}

Stage 30 â€” UI Part 1ï¼šæ–°å¢ç™»å…¥ä»‹é¢ï¼ˆHTMLï¼‰

åœ¨ä½ çš„ frontend/ æ–°å¢ï¼š

login.html

<div class="login-box">
  <h2>P2P Chat Login</h2>

  <input id="user" placeholder="Username" />
  <input id="pass" placeholder="Password" type="password" />

  <button onclick="login()">Login</button>
  <button onclick="register()">Register</button>

  <p id="msg"></p>
</div>

Stage 31 â€” UI Part 2ï¼šç™»å…¥ API JS å¯¦ä½œ

login.js

async function login() {
    const res = await fetch("http://localhost:8089/login", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
            username: user.value,
            password: pass.value,
        }),
    });

    if (!res.ok) {
        msg.textContent = "Login failed";
        return;
    }

    const data = await res.json();
    localStorage.setItem("token", data.token);
    localStorage.setItem("username", data.username);

    window.location.href = "chat.html";
}

Stage 32 â€” UI Part 3ï¼šChat ä»‹é¢è®Šæˆä½¿ç”¨è€…å‹å–„ç‰ˆ

ä½ çµ¦çš„ç•«é¢ä¸­ï¼š

connected: [127.0.0.1:9001 127.0.0.1:6851] | desired: []
/peers /history /stats


ä¸€èˆ¬ä½¿ç”¨è€…çœ‹ä¸æ‡‚ï¼Œæˆ‘å€‘æ”¹æˆï¼š

âœ” å·²é€£ç·šçš„ç”¨æˆ¶åˆ—è¡¨
âœ” ä¸å†é¡¯ç¤º port
âœ” é¡¯ç¤ºã€Œåœ¨ç·šã€æˆ–ã€Œé›¢ç·šã€ç‹€æ…‹
âœ” å¯é¡¯ç¤º DM / ç¾¤èŠ

UI æ”¹ç‰ˆå¦‚ä¸‹ï¼š

èˆŠç‰ˆï¼ˆå·¥ç¨‹å¸«è¦–è§’ï¼‰
connected: [127.0.0.1:9001 127.0.0.1:6851]

æ–°ç‰ˆï¼ˆä½¿ç”¨è€…è¦–è§’ï¼‰
ğŸŸ¢ Online Users
- bob
- alice

Stage 33 â€” å¾Œç«¯åœ¨é€£ç·š handshake æ™‚å‚³é username

å…ˆå‰çš„ P2P handshakingï¼ˆTCPï¼‰åªå‚³ port
ç¾åœ¨æ”¹æˆï¼š

struct {
    username: "bob",
    token: "jwtâ€¦"
}

Stage 34 â€” P2P ç¶²è·¯å±¤åŠ å…¥ä½¿ç”¨è€…è³‡è¨Š

ç•¶ A é€£ç·šåˆ° B æ™‚ï¼š

A å‚³è‡ªå·±çš„è³‡è¨Šï¼š

{
  "username": "bob",
  "token": "xxx"
}


B ä¿å­˜ peer.username

Chat UI é¡¯ç¤ºåå­—ï¼Œè€Œä¸æ˜¯ IP

Stage 35 â€” UI Part 4ï¼šèŠå¤©å€å¡Šæ”¹ç‚ºåƒ LINE/Discord

èˆ‰ä¾‹ï¼š

[12:31] bob:
hello

[12:32] alice:
hi!


ç¾åŒ–æ–¹å¼ï¼š

å·¦å³ bubble

é¡è‰²å€åˆ†è‡ªå·±èˆ‡ä»–äºº

è‡ªå·±çš„è¨Šæ¯é å³

Stage 36 â€” æ–°å¢ã€Œä½¿ç”¨è€…æ­·å²è¨Šæ¯ã€å„²å­˜

æ–°å¢ SQLite tableï¼š

CREATE TABLE messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sender TEXT,
    receiver TEXT,   -- null = public message
    content TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

APIï¼šå–å¾—æ­·å²è¨Šæ¯
GET /history?user=bob

UI è¡Œç‚ºï¼š

ç™»å…¥å¾Œè‡ªå‹•è¼‰å…¥ chat history

æ–°è¨Šæ¯æ™‚ append

ğŸ‰ æœ€çµ‚æˆæœï¼ˆStage 36 å®Œæˆå¾Œï¼‰

ä½ çš„èŠå¤© App å°‡å…·å‚™ï¼š

âœ” å¯ç™»å…¥/è¨»å†Š
âœ” çœŸæ­£çš„å¸³è™Ÿç®¡ç†ï¼ˆDB å„²å­˜ï¼‰
âœ” JWT login
âœ” P2P èŠå¤©ï¼ˆä¸ç¶“ serverï¼‰
âœ” UI åƒ Discord/LINE
âœ” é¡¯ç¤ºç·šä¸Šç”¨æˆ¶ï¼ˆç”¨æˆ¶åï¼Œè€Œé IPï¼‰
âœ” èŠå¤©æ³¡æ³¡
âœ” DM, å…¬é–‹èŠå¤©å®¤
âœ” æ­·å²è¨Šæ¯å„²å­˜
âœ” UXå¤§å¹…æå‡